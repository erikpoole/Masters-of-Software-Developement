package homework2;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

/*
//This class should store all the data provided by the 12 byte DNS header. 
//See the spec for all the fields needed.
//
//This class should have the following public methods:
//
//static DNSHeader decodeHeader(InputStream) --
//read the header from an input stream 
//(we'll use a ByteArrayInputStream but we will only use the basic read methods 
//of input stream to read 1 byte, or to fill in a byte array, so we'll be generic).
//
//static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) -- 
//This will create the header for the response. It will copy some fields from the request
//
//void writeBytes(OutputStream) --
//encode the header to bytes to be sent back to the client. 
//The OutputStream interface has methods to write a single byte or an array of bytes.
//
//String toString() -- 
//Return a human readable string version of a header object. 
//A reasonable implementation can be autogenerated by your IDE.
//You'll probably need a few getters, but you should NOT provide any setters.
 */


public class DNSHeader {
	public int id;
	private int qr;
	private int opcode;
	private int aa;
	private int tc;
	private int rd;
	private int ra;
	private int z;
	private int ad;
	private int cd;
	private int rcode;
	private int qdCount;
	private int anCount;
	private int nsCount;
	private int arCount;
	
	
	public int getQdCount() {
		return qdCount;
	}
	
	public int getAnCount() {
		return anCount;
	}
	
	public int getNsCount() {
		return nsCount;
	}
	
	public int getArCount() {
		return arCount;
	}
	
	@Override
	public String toString() {
		return "DNSHeader [id=" + id + ", qr=" + qr + ", opcode=" + opcode + ", aa=" + aa + ", tc=" + tc + ", rd=" + rd
				+ ", ra=" + ra + ", z=" + z + ", ad=" + ad + ", cd=" + cd + ", rcode=" + rcode + ", qdcount=" + qdCount
				+ ", ancount=" + anCount + ", nscount=" + nsCount + ", arcount=" + arCount + "]";
	}


	public void writeBytes(ByteArrayOutputStream outStream) {
		DNSMessage.writeField(id, 2, outStream);
		
		byte qrByte = (byte) qr;
		qrByte <<= 7;
		
		byte opCodeByte = (byte) opcode;
		opCodeByte <<= 3;
		
		byte aaByte = (byte) aa;
		aaByte <<= 2;
		
		byte tcByte = (byte) tc;
		tcByte <<= 1;
		
		byte rdByte = (byte) rd;
		
		byte combinedByteOne = qrByte;
		combinedByteOne |= opCodeByte;
		combinedByteOne |= aaByte;
		combinedByteOne |= tcByte;
		combinedByteOne |= rdByte;
		outStream.write(combinedByteOne);
		
		byte raByte = (byte) ra;
		raByte <<= 7;
		
		byte zByte = (byte) z;
		zByte <<= 6;
		
		byte adByte = (byte) ad;
		adByte <<= 5;
		
		byte cdByte = (byte) cd;
		cdByte <<= 4;
		
		byte rcodeByte = (byte) rcode;
		
		byte combinedByteTwo = raByte;
		combinedByteTwo |= zByte;
		combinedByteTwo |= adByte;
		combinedByteTwo |= cdByte;
		combinedByteTwo |= rcodeByte;
		outStream.write(combinedByteTwo);
		
		DNSMessage.writeField(qdCount, 2, outStream);
		DNSMessage.writeField(anCount, 2, outStream);
		DNSMessage.writeField(nsCount, 2, outStream);
		DNSMessage.writeField(arCount, 2, outStream);
	}
	
	public static DNSHeader decodeHeader(ByteArrayInputStream inStream) throws IOException {
		DNSHeader header = new DNSHeader();
		
		header.id = DNSMessage.decodeField(inStream, 2);
		
		byte[] inBuffer = new byte[2];
		inStream.read(inBuffer);
		
		int mask = 0xf;
		header.opcode |= inBuffer[0] >> 3;
		header.opcode &= mask;
		header.rcode |= inBuffer[1];
		header.rcode &= mask;	
		
		header.qr = decodeSingleBitField(inBuffer, 0, 0);
		header.aa = decodeSingleBitField(inBuffer, 0, 5);
		header.tc = decodeSingleBitField(inBuffer, 0, 6);
		header.rd = decodeSingleBitField(inBuffer, 0, 7);
		header.ra = decodeSingleBitField(inBuffer, 1, 0);
		header.z = decodeSingleBitField(inBuffer, 1, 1);
		header.ad = decodeSingleBitField(inBuffer, 1, 2);
		header.cd = decodeSingleBitField(inBuffer, 1, 3);

		header.qdCount = DNSMessage.decodeField(inStream, 2);
		header.anCount = DNSMessage.decodeField(inStream, 2);
		header.nsCount = DNSMessage.decodeField(inStream, 2);
		header.arCount = DNSMessage.decodeField(inStream, 2);
		
		return header;
		
	}
	
	public static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) {
		DNSHeader workingHeader = request.getHeader();
		
		workingHeader.id = request.getHeader().id;
		workingHeader.qr = 1;
		workingHeader.opcode = 0;
		workingHeader.aa = 0;
		workingHeader.tc = 0;
		workingHeader.rd = 1;
		workingHeader.ra = 1;
		workingHeader.z = 0;
		workingHeader.ad = 0;
		workingHeader.cd = 0;
		workingHeader.rcode = 0;
		workingHeader.qdCount = response.getQuestions().length;
		workingHeader.anCount = response.getAnswers().length;
		workingHeader.nsCount = response.getAuthorityRecords().length;
		workingHeader.arCount = response.getAdditionalRecords().length;

		return workingHeader;
	}
	
	private static int decodeSingleBitField(final byte[] inBuffer, int bytePosition, int bitPosition) {		
		int value = 0;
		int mask = 0xff;
		value |= inBuffer[bytePosition] << bitPosition;
		value &= mask;
		value >>= 7;
		
		return value;
	}
	
	


}
