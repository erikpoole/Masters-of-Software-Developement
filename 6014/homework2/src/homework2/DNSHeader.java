package homework2;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.OutputStream;

/*
This class should store all the data provided by the 12 byte DNS header. 
See the spec for all the fields needed.

This class should have the following public methods:

static DNSHeader decodeHeader(InputStream) --
read the header from an input stream 
(we'll use a ByteArrayInputStream but we will only use the basic read methods 
of input stream to read 1 byte, or to fill in a byte array, so we'll be generic).

static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) -- 
This will create the header for the response. It will copy some fields from the request

void writeBytes(OutputStream) --
encode the header to bytes to be sent back to the client. 
The OutputStream interface has methods to write a single byte or an array of bytes.

String toString() -- 
Return a human readable string version of a header object. 
A reasonable implementation can be autogenerated by your IDE.
You'll probably need a few getters, but you should NOT provide any setters.


 */


public class DNSHeader {
	private int id;
	private int qr;
	private int opcode;
	private int aa;
	private int tc;
	private int rd;
	private int ra;
	private int z;
	private int ad;
	private int cd;
	private int rcode;
	private int qdCount;
	private int anCount;
	private int nsCount;
	private int arCount;
	
	private void writeBytes(OutputStream outStream) {
		
	}
	
	public int getQdCount() {
		return qdCount;
	}
	
	public int getAnCount() {
		return anCount;
	}
	
	public int getNsCount() {
		return nsCount;
	}
	
	public int getArCount() {
		return arCount;
	}
	
	@Override
	public String toString() {
		return "DNSHeader [id=" + id + ", qr=" + qr + ", opcode=" + opcode + ", aa=" + aa + ", tc=" + tc + ", rd=" + rd
				+ ", ra=" + ra + ", z=" + z + ", ad=" + ad + ", cd=" + cd + ", rcode=" + rcode + ", qdcount=" + qdCount
				+ ", ancount=" + anCount + ", nscount=" + nsCount + ", arcount=" + arCount + "]";
	}



	//most significant bit on left
	//byte to int is causing promotion problems
	public static DNSHeader decodeHeader(final ByteArrayInputStream inStream) throws IOException {
		DNSHeader header = new DNSHeader();
		byte[] inBuffer = new byte[12];
		inStream.read(inBuffer);
		
//		for (byte b : inBuffer) {
//			System.out.println(String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0'));
//		}
		
		int mask = 0xf;
		
		header.opcode |= inBuffer[2] >> 3;
		header.opcode &= mask;

		header.rcode &= mask;

		header.id = handleTwoByteField(inBuffer, 0);
		header.qdCount = handleTwoByteField(inBuffer, 4);
		header.anCount = handleTwoByteField(inBuffer, 6);
		header.nsCount = handleTwoByteField(inBuffer, 8);
		header.arCount = handleTwoByteField(inBuffer, 10);

		header.qr = handleSingleBitField(inBuffer, 2, 0);
		header.aa = handleSingleBitField(inBuffer, 2, 5);
		header.tc = handleSingleBitField(inBuffer, 2, 6);
		header.rd = handleSingleBitField(inBuffer, 2, 7);
		header.ra = handleSingleBitField(inBuffer, 3, 0);
		header.z = handleSingleBitField(inBuffer, 3, 1);
		header.ad = handleSingleBitField(inBuffer, 3, 2);
		header.cd = handleSingleBitField(inBuffer, 3, 3);
		
//		System.out.println("Header:");
//		System.out.println("0 & 1: " + Integer.toBinaryString(header.id));
//		System.out.println("2: " + Integer.toBinaryString(header.qr));
//		System.out.println("2: " + Integer.toBinaryString(header.opcode));
//		System.out.println("2: " + Integer.toBinaryString(header.aa));
//		System.out.println("2: " + Integer.toBinaryString(header.tc));
//		System.out.println("2: " + Integer.toBinaryString(header.rd));
//		System.out.println("3: " + Integer.toBinaryString(header.ra));
//		System.out.println("3: " + Integer.toBinaryString(header.z));
//		System.out.println("3: " + Integer.toBinaryString(header.ad));
//		System.out.println("3: " + Integer.toBinaryString(header.cd));
//		System.out.println("3: " + Integer.toBinaryString(header.rcode));
//		System.out.println("4 & 5: " + Integer.toBinaryString(header.qdCount));
//		System.out.println("6 & 7: " + Integer.toBinaryString(header.anCount));
//		System.out.println("8 & 9: " + Integer.toBinaryString(header.nsCount));
//		System.out.println("10 & 11: " + Integer.toBinaryString(header.arCount));
		
		return header;
		
	}
	
	public static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) {
		return null;
	}
	
	
	private static int handleTwoByteField(final byte[] inBuffer, int firstBytePosition) {
		int mask = 0xff;
		int byte1 = inBuffer[firstBytePosition] & mask;
		int byte2 = inBuffer[firstBytePosition+1] & mask;

		int output = 0;
		output |= byte1 << 8;
		output |= byte2;
		
		return output;
	}
	
	private static int handleSingleBitField(final byte[] inBuffer, int bytePosition, int bitPosition) {		
		int value = 0;
		int mask = 0xff;
		value |= inBuffer[bytePosition] << bitPosition;
		value &= mask;
		value >>= 7;
		
		return value;
	}
	
	


}
