package homework2;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

/*
//This class should store all the data provided by the 12 byte DNS header. 
//See the spec for all the fields needed.
//
//This class should have the following public methods:
//
//static DNSHeader decodeHeader(InputStream) --
//read the header from an input stream 
//(we'll use a ByteArrayInputStream but we will only use the basic read methods 
//of input stream to read 1 byte, or to fill in a byte array, so we'll be generic).
//
//static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) -- 
//This will create the header for the response. It will copy some fields from the request
//
//void writeBytes(OutputStream) --
//encode the header to bytes to be sent back to the client. 
//The OutputStream interface has methods to write a single byte or an array of bytes.
//
//String toString() -- 
//Return a human readable string version of a header object. 
//A reasonable implementation can be autogenerated by your IDE.
//You'll probably need a few getters, but you should NOT provide any setters.
 */


public class DNSHeader {
	public int id;
	private int qr;
	private int opcode;
	private int aa;
	private int tc;
	private int rd;
	private int ra;
	private int z;
	private int ad;
	private int cd;
	private int rcode;
	private int qdCount;
	private int anCount;
	private int nsCount;
	private int arCount;
	
	
	
	public int getQdCount() {
		return qdCount;
	}
	
	public int getAnCount() {
		return anCount;
	}
	
	public int getNsCount() {
		return nsCount;
	}
	
	public int getArCount() {
		return arCount;
	}
	
	@Override
	public String toString() {
		return "DNSHeader [id=" + id + ", qr=" + qr + ", opcode=" + opcode + ", aa=" + aa + ", tc=" + tc + ", rd=" + rd
				+ ", ra=" + ra + ", z=" + z + ", ad=" + ad + ", cd=" + cd + ", rcode=" + rcode + ", qdcount=" + qdCount
				+ ", ancount=" + anCount + ", nscount=" + nsCount + ", arcount=" + arCount + "]";
	}


	public void writeBytes(ByteArrayOutputStream outStream) {
		DNSMessage.writeField(id, 2, outStream);
		
		byte qrByte = (byte) qr;
		qrByte <<= 7;
		
		byte opCodeByte = (byte) opcode;
		opCodeByte <<= 3;
		
		byte aaByte = (byte) aa;
		aaByte <<= 2;
		
		byte tcByte = (byte) tc;
		tcByte <<= 1;
		
		byte rdByte = (byte) rd;
		
		byte combinedByteOne = qrByte;
		combinedByteOne |= opCodeByte;
		combinedByteOne |= aaByte;
		combinedByteOne |= tcByte;
		combinedByteOne |= rdByte;
		outStream.write(combinedByteOne);
		
		byte raByte = (byte) ra;
		raByte <<= 7;
		
		byte zByte = (byte) z;
		zByte <<= 6;
		
		byte adByte = (byte) ad;
		adByte <<= 5;
		
		byte cdByte = (byte) cd;
		cdByte <<= 4;
		
		byte rcodeByte = (byte) rcode;
		
		byte combinedByteTwo = raByte;
		combinedByteTwo |= zByte;
		combinedByteTwo |= adByte;
		combinedByteTwo |= cdByte;
		combinedByteTwo |= rcodeByte;
		outStream.write(combinedByteTwo);
		
		DNSMessage.writeField(qdCount, 2, outStream);
		DNSMessage.writeField(anCount, 2, outStream);
		DNSMessage.writeField(nsCount, 2, outStream);
		DNSMessage.writeField(arCount, 2, outStream);
	}
	
	//most significant bit on left
	//byte to int is causing promotion problems
	public static DNSHeader decodeHeader(ByteArrayInputStream inStream) throws IOException {
		DNSHeader header = new DNSHeader();
		byte[] inBuffer = new byte[12];
		inStream.read(inBuffer);
		
//		for (byte b : inBuffer) {
//			System.out.println(String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0'));
//		}
		
		int mask = 0xf;
		
		header.opcode |= inBuffer[2] >> 3;
		header.opcode &= mask;

		header.rcode &= mask;

		header.id = handleTwoByteField(inBuffer, 0);
		header.qdCount = handleTwoByteField(inBuffer, 4);
		header.anCount = handleTwoByteField(inBuffer, 6);
		header.nsCount = handleTwoByteField(inBuffer, 8);
		header.arCount = handleTwoByteField(inBuffer, 10);

		header.qr = handleSingleBitField(inBuffer, 2, 0);
		header.aa = handleSingleBitField(inBuffer, 2, 5);
		header.tc = handleSingleBitField(inBuffer, 2, 6);
		header.rd = handleSingleBitField(inBuffer, 2, 7);
		header.ra = handleSingleBitField(inBuffer, 3, 0);
		header.z = handleSingleBitField(inBuffer, 3, 1);
		header.ad = handleSingleBitField(inBuffer, 3, 2);
		header.cd = handleSingleBitField(inBuffer, 3, 3);
		
//		System.out.println("Header:");
//		System.out.println("0 & 1: " + Integer.toBinaryString(header.id));
//		System.out.println("2: " + Integer.toBinaryString(header.qr));
//		System.out.println("2: " + Integer.toBinaryString(header.opcode));
//		System.out.println("2: " + Integer.toBinaryString(header.aa));
//		System.out.println("2: " + Integer.toBinaryString(header.tc));
//		System.out.println("2: " + Integer.toBinaryString(header.rd));
//		System.out.println("3: " + Integer.toBinaryString(header.ra));
//		System.out.println("3: " + Integer.toBinaryString(header.z));
//		System.out.println("3: " + Integer.toBinaryString(header.ad));
//		System.out.println("3: " + Integer.toBinaryString(header.cd));
//		System.out.println("3: " + Integer.toBinaryString(header.rcode));
//		System.out.println("qdCount: " + Integer.toBinaryString(header.qdCount));
//		System.out.println("anCount: " + Integer.toBinaryString(header.anCount));
//		System.out.println("nsCount: " + Integer.toBinaryString(header.nsCount));
//		System.out.println("arCount: " + Integer.toBinaryString(header.arCount));
		
		return header;
		
	}
	
	public static DNSHeader buildResponseHeader(DNSMessage request, DNSMessage response) {
		
		DNSHeader workingHeader = request.getHeader();
		workingHeader.id = request.getHeader().id;
		workingHeader.qr = 1;
		workingHeader.opcode = 0;
		workingHeader.aa = 0;
		workingHeader.tc = 0;
		workingHeader.rd = 1;
		workingHeader.ra = 1;
		workingHeader.z = 0;
		workingHeader.ad = 0;
		workingHeader.cd = 0;
		workingHeader.rcode = 0;
		workingHeader.qdCount = response.getQuestions().length;
		workingHeader.anCount = response.getAnswers().length;
		workingHeader.nsCount = response.getAuthorityRecords().length;
		workingHeader.arCount = response.getAdditionalRecords().length;

		return workingHeader;
	}
	
	private static int handleTwoByteField(final byte[] inBuffer, int firstBytePosition) {
		int mask = 0xff;
		int byte1 = inBuffer[firstBytePosition] & mask;
		int byte2 = inBuffer[firstBytePosition+1] & mask;

		int output = 0;
		output |= byte1 << 8;
		output |= byte2;
		
		return output;
	}
	
	private static int handleSingleBitField(final byte[] inBuffer, int bytePosition, int bitPosition) {		
		int value = 0;
		int mask = 0xff;
		value |= inBuffer[bytePosition] << bitPosition;
		value &= mask;
		value >>= 7;
		
		return value;
	}
	
	


}
